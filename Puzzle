from collections import deque

goal = (1, 2, 3,
        4, 5, 6,
        7, 8, 0)

def bfs(start):
    queue = deque([start])
    visited = {start: None}

    while queue:
        state = queue.popleft()

        if state == goal:
            break

        zero = state.index(0)

        # Possible moves: up, down, left, right
        for move in (zero - 3, zero + 3, zero - 1, zero + 1):

            if 0 <= move < 9:

                # Prevent left-right wrapping
                if zero % 3 == 0 and move == zero - 1:
                    continue
                if zero % 3 == 2 and move == zero + 1:
                    continue

                new_state = list(state)
                new_state[zero], new_state[move] = new_state[move], new_state[zero]
                new_state = tuple(new_state)

                if new_state not in visited:
                    visited[new_state] = state
                    queue.append(new_state)

    # Reconstruct path
    path = []
    while state is not None:
        path.append(state)
        state = visited[state]

    return path[::-1]


# -------- Main Program --------
print("Enter puzzle (use 0 for empty):")

start = []
for i in range(3):
    start += list(map(int, input().split()))

start = tuple(start)

print("\nSolution:\n")
for step in bfs(start):
    print(step[0:3])
    print(step[3:6])
    print(step[6:9])
    print()
